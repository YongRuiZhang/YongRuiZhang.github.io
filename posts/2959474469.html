<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>计算机操作系统复习重点 | 秋白's Blog</title><meta name="author" content="秋白"><meta name="copyright" content="秋白"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="我在参加大三考试时的计算机操作系统复习资料">
<meta property="og:type" content="article">
<meta property="og:title" content="计算机操作系统复习重点">
<meta property="og:url" content="http://yongruizhang.cn/posts/2959474469.html">
<meta property="og:site_name" content="秋白&#39;s Blog">
<meta property="og:description" content="我在参加大三考试时的计算机操作系统复习资料">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://yongruizhang-image.oss-cn-chengdu.aliyuncs.com/img/img127.png">
<meta property="article:published_time" content="2023-12-06T14:10:01.000Z">
<meta property="article:modified_time" content="2024-02-28T11:22:06.443Z">
<meta property="article:author" content="秋白">
<meta property="article:tag" content="计算机操作系统">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://yongruizhang-image.oss-cn-chengdu.aliyuncs.com/img/img127.png"><link rel="shortcut icon" href="https://yongruizhang-image.oss-cn-chengdu.aliyuncs.com/img/qiubai-logo.png"><link rel="canonical" href="http://yongruizhang.cn/posts/2959474469.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":500},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"bottom-left"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '计算机操作系统复习重点',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-02-28 19:22:06'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = url => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      link.onload = () => resolve()
      link.onerror = () => reject()
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><script src="https://cdn.jsdelivr.net/npm/echarts@5.4.1/dist/echarts.min.js"></script><link rel="stylesheet" href="/css/twikoo2.css"><link rel="stylesheet" href="/css/twikoo1.css"><link rel="stylesheet" href="/css/footer1.css"><link rel="apple-touch-icon" href="/img/favicon.jpeg"><meta name="apple-mobile-web-app-title" content="秋白's Blog"><link rel="bookmark" href="/img/favicon.jpeg"><link rel="apple-touch-icon-precomposed" sizes="180x180" href="/img/favicon.jpeg" ><link rel="stylesheet" href="/css/footer_bg.css"><link rel="stylesheet" href="/css/background.css"><link rel="stylesheet" href="/css/nav1.css"><meta name="baidu-site-verification" content="codeva-qQP2iZOMLX" /><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://yongruizhang-image.oss-cn-chengdu.aliyuncs.com/img/Downloads/favicon.png" onerror="onerror=null;src='https://yongruizhang-image.oss-cn-chengdu.aliyuncs.com/img/Downloads/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">119</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">64</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">78</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fa-fw fa-regular fa-folder-open"></i><span> 找文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fa-solid fa-envelope-open-text"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://yongruizhang-image.oss-cn-chengdu.aliyuncs.com/img/img127.png')"><nav id="nav"><span id="blog-info"><a href="/" title="秋白's Blog"><img class="site-icon" src="https://yongruizhang-image.oss-cn-chengdu.aliyuncs.com/img/Downloads/favicon.png"/><span class="site-name">秋白's Blog</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fa-fw fa-regular fa-folder-open"></i><span> 找文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fa-solid fa-envelope-open-text"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div><div id="nav-right"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">计算机操作系统复习重点</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-12-06T14:10:01.000Z" title="发表于 2023-12-06 22:10:01">2023-12-06</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-02-28T11:22:06.443Z" title="更新于 2024-02-28 19:22:06">2024-02-28</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%AD%A6%E6%A0%A1%E8%AF%BE%E7%A8%8B/">学校课程</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%AD%A6%E6%A0%A1%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">计算机操作系统</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">7.5k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>24分钟</span></span><span class="post-meta-separator">|</span><span id="" data-flag-title="计算机操作系统复习重点"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="twikoo_visitors"><i class="fa-solid fa-spinner fa-spin"></i></span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/posts/2959474469.html#post-comment"><span id="twikoo-count"><i class="fa-solid fa-spinner fa-spin"></i></span></a></span></div></div></div></header><main class="layout" id="content-inner"><div id="post" style="background: white; backdrop-filter: blur(5px); opacity: 0.98"><article class="post-content" id="article-container"><h1 id="什么是操作系统？操作系统的作用有哪些"><a href="#什么是操作系统？操作系统的作用有哪些" class="headerlink" title="什么是操作系统？操作系统的作用有哪些"></a>什么是操作系统？操作系统的作用有哪些</h1><p>操作系统是<strong>一组</strong>控制和管理计算机硬件和软件资源，合理地组织计算机工作流程，以及方便用户使用的<strong>程序集合</strong>。</p>
<h2 id="作用："><a href="#作用：" class="headerlink" title="作用："></a>作用：</h2><ol>
<li>作为用户与计算机硬件系统之间的接口</li>
<li>作为计算机系统资源的管理者</li>
<li>用作扩充机器</li>
</ol>
<hr>
<h1 id="操作系统通常具有哪4个基本特征"><a href="#操作系统通常具有哪4个基本特征" class="headerlink" title="操作系统通常具有哪4个基本特征"></a>操作系统通常具有哪4个基本特征</h1><ul>
<li>并发</li>
<li>共享</li>
<li>虚拟</li>
<li>异步性</li>
</ul>
<hr>
<h1 id="操作系统应实现哪些基本目标"><a href="#操作系统应实现哪些基本目标" class="headerlink" title="操作系统应实现哪些基本目标"></a>操作系统应实现哪些基本目标</h1><ol>
<li>使计算机系统更易于使用（方便性）</li>
<li>以一种效率的方式使用资源（有效性）</li>
<li>采用模块化结构，易于增、删、改（可扩充性）</li>
<li>要求统一开放的环境，能通过网络集成化并正确、有效地协同工作，实现应用程序的移植（开放性）</li>
</ol>
<hr>
<h1 id="操作系统的基本功能有哪些"><a href="#操作系统的基本功能有哪些" class="headerlink" title="操作系统的基本功能有哪些"></a>操作系统的基本功能有哪些</h1><ol>
<li><p><strong>处理器管理</strong>：<strong>主要控制和管理CPU的工作，控制和管理处理机</strong>。主要功能是进程控制、进程同步、进程通信和进程调度等</p>
</li>
<li><p><strong>存储管理</strong>：主要<strong>进行内存的分配和管理</strong>。主要功能是内存分配、内存保护、地址映射、内存扩充等</p>
</li>
<li><p><strong>设备管理</strong>：主要管理<strong>基本的输入输出设备</strong>。主要功能是缓冲管理、设备分配、设备处理、虚拟设备等</p>
</li>
<li><p><strong>文件管理</strong>：负责<strong>对计算机文件</strong>的<strong>组织、存储、操作和保护</strong>等。</p>
</li>
<li><strong>用户接口管理</strong>：主要负责管理<strong>操作系统提供给用户的接口</strong>，使用户能够方便地与计算机系统交互。主要功能为命令接口，程序接口，图形接口等。</li>
</ol>
<h2 id="处理机管理功能"><a href="#处理机管理功能" class="headerlink" title="处理机管理功能"></a>处理机管理功能</h2><p>主要任务：</p>
<ul>
<li>对处理机进行<strong>分配</strong></li>
<li>对处理机<strong>运行进行有效的控制和管理</strong></li>
</ul>
<p>处理机管理的功能：</p>
<ul>
<li>进程控制</li>
<li>进程同步</li>
<li>进程通信</li>
<li>调度</li>
</ul>
<h2 id="存储器管理功能"><a href="#存储器管理功能" class="headerlink" title="存储器管理功能"></a>存储器管理功能</h2><p>主要任务：</p>
<ul>
<li>为多道程序的运行提供良好的环境</li>
<li>方便用户使用存储器</li>
<li>提高存储器的利用率</li>
<li>从逻辑上扩充内存</li>
</ul>
<p>功能：</p>
<ul>
<li>内存分配</li>
<li>内存保护</li>
<li>地址映射</li>
<li>内存扩充</li>
</ul>
<h2 id="设备管理功能"><a href="#设备管理功能" class="headerlink" title="设备管理功能"></a>设备管理功能</h2><p>主要任务：</p>
<ul>
<li>完成用户提出的I/O请求</li>
<li>为用户分配I/O设备</li>
<li>提高I/O设备的利用率及速度</li>
<li>方便用户使用I/O设备</li>
</ul>
<p>功能：</p>
<ul>
<li>缓冲管理</li>
<li>设备分配</li>
<li>设备处理</li>
<li>虚拟设备</li>
</ul>
<h2 id="文件管理功能"><a href="#文件管理功能" class="headerlink" title="文件管理功能"></a>文件管理功能</h2><p>主要任务：</p>
<ul>
<li>对用户文件和系统文件进行管理</li>
<li>方便用户使用文件</li>
<li>保证文件的安全性</li>
</ul>
<p>功能：</p>
<ul>
<li>文件存储空间的管理</li>
<li>目录管理</li>
<li>文件的读、写管理</li>
<li>文件的共享与保护</li>
</ul>
<h2 id="用户接口管理的功能"><a href="#用户接口管理的功能" class="headerlink" title="用户接口管理的功能"></a>用户接口管理的功能</h2><p>主要任务：</p>
<ul>
<li>方便用户使用操作系统</li>
</ul>
<p>功能：</p>
<ul>
<li>命令接口</li>
<li>程序接口（系统调用）</li>
<li>图形接口</li>
</ul>
<hr>
<h1 id="什么是通用操作系统？"><a href="#什么是通用操作系统？" class="headerlink" title="什么是通用操作系统？"></a>什么是通用操作系统？</h1><p>如果一个操作系统兼有<strong>批处理、分时和实时系统三者或二者的功能</strong>，则称该操作系统为通用操作系统。</p>
<hr>
<h1 id="根据程序段绘制语句的前驱图"><a href="#根据程序段绘制语句的前驱图" class="headerlink" title="根据程序段绘制语句的前驱图"></a>根据程序段绘制语句的前驱图</h1><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://yongruizhang-image.oss-cn-chengdu.aliyuncs.com/img/Downloads/image-20231116191200023.png" alt="image-20231116191200023" style="zoom:50%;" /></p>
<p>程序的顺序执行：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://yongruizhang-image.oss-cn-chengdu.aliyuncs.com/img/Downloads/image-20231116191229930.png" alt="image-20231116191229930" style="zoom:50%;" /></p>
<hr>
<h1 id="简要描述程序和进程之间的区别"><a href="#简要描述程序和进程之间的区别" class="headerlink" title="简要描述程序和进程之间的区别"></a>简要描述程序和进程之间的区别</h1><ol>
<li>程序是指令的有序集合，其本身没有任何运行的含义，它是一个<strong>静态</strong>的概念。而进程是程序在处理机上的一次执行过程，它是一个<strong>动态</strong>概念。</li>
<li>程序的<strong>存在是永久</strong>的。而<strong>进程则是有生命期</strong>的，它因创建而产生，因调度而执行，因得不到资源而暂停，因撤消而消亡。</li>
<li>程序仅是<strong>指令的有序集合</strong>。而进程则由<strong>程序段、相关数据段和进程控制块（PCB）</strong>组成。</li>
<li>进程与程序之间不是一一对应。</li>
</ol>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>程序</th>
<th>进程</th>
</tr>
</thead>
<tbody>
<tr>
<td>概念</td>
<td>静态</td>
<td>动态</td>
</tr>
<tr>
<td>所在存储器</td>
<td>外存</td>
<td>内存</td>
</tr>
<tr>
<td>存在时间</td>
<td>永久</td>
<td>有生命期</td>
</tr>
<tr>
<td>组成</td>
<td>有序指令</td>
<td>程序段,数据段,PCB</td>
</tr>
<tr>
<td>对应关系</td>
<td>一个程序可对应多个进程<br/>一个进程可对应多个程序</td>
</tr>
</tbody>
</table>
</div>
<hr>
<h1 id="请简要描述进程的3种基本状态"><a href="#请简要描述进程的3种基本状态" class="headerlink" title="请简要描述进程的3种基本状态"></a>请简要描述进程的3种基本状态</h1><ul>
<li><p><strong>就绪</strong>: 进程已获得了除处理机以外的所有资源，等待分配处理机执行的等待状态。</p>
</li>
<li><p>运行/<strong>执行</strong>: 当一个进程获得必要的资源并正在处理机上执行的状态。</p>
</li>
<li><p>等待/<strong>阻塞</strong>: 正在执行的进程由于发生某事件而暂时无法执行下去，此时进程所处的状态。</p>
</li>
</ul>
<hr>
<h1 id="进程三种基本状态的转换图"><a href="#进程三种基本状态的转换图" class="headerlink" title="进程三种基本状态的转换图"></a>进程三种基本状态的转换图</h1><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://yongruizhang-image.oss-cn-chengdu.aliyuncs.com/img/Downloads/image-20231118220040451.png" alt="image-20231118220040451" style="zoom:43%;" /></p>
<hr>
<h1 id="进程创建的流程图"><a href="#进程创建的流程图" class="headerlink" title="进程创建的流程图"></a>进程创建的流程图</h1><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://yongruizhang-image.oss-cn-chengdu.aliyuncs.com/img/Downloads/image-20231118220600417.png" alt="image-20231118220600417" style="zoom:50%;" /></p>
<hr>
<h1 id="同步机制应当遵循哪些规则"><a href="#同步机制应当遵循哪些规则" class="headerlink" title="同步机制应当遵循哪些规则"></a>同步机制应当遵循哪些规则</h1><ul>
<li><strong>有空让进(空闲让进）:</strong>当无进程处于临界区时，表明临界资源处于空闲状态，应允许一个请求进入临界区的进程立即进入自己的临界区，以有效地利用临界资源。</li>
<li><strong>互斥（忙则等待）:</strong>当已有进程进入临界区时，表明临界资源正在被访问，因而其他试图进入临界区的进程必须等待，以保证对临界资源的互斥访问</li>
<li><strong>有限等待:</strong>对要求访问临界资源的进程，应保证在有限时间内能进入自己的临界区，以免陷入“死等”状态.</li>
<li><strong>让权等待:</strong>当进程不能进入自己的临界区时，应立即释放处理机，以免进程陷入“忙等”。</li>
</ul>
<hr>
<h1 id="关于信号量的典型例题"><a href="#关于信号量的典型例题" class="headerlink" title="关于信号量的典型例题"></a>关于信号量的典型例题</h1><h2 id="读者-写者问题"><a href="#读者-写者问题" class="headerlink" title="读者-写者问题"></a>读者-写者问题</h2><p>writer进程要求写或修改。允许多个reader进程同时读共享数据，但绝不允许一个writer进程与其它的reader进程或writer进程同时访问，即writer进程必须与其它进程互斥访问共享对象。请用PV操作实现相应的reader和writer进程</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">semaphore rmutex = <span class="number">1</span>; <span class="comment">/* 读互斥信号量 */</span></span><br><span class="line">semaphore wmutex = <span class="number">1</span>; <span class="comment">/* 写互斥信号量 */</span></span><br><span class="line"><span class="type">int</span> readcount = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">Main</span>() &#123;</span><br><span class="line">    <span class="function">cobegin</span></span><br><span class="line"><span class="function">        <span class="title">reader</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="built_in">writer</span>();</span><br><span class="line">    coend</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">reader</span>() &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="built_in">P</span>(rmutex);</span><br><span class="line">        <span class="keyword">if</span> (readcount == <span class="number">0</span>) <span class="built_in">P</span>(wmutex); <span class="comment">/* 第一位读者阻止写者 */</span></span><br><span class="line">        readcount++;</span><br><span class="line">        <span class="built_in">V</span>(rmutex);</span><br><span class="line">        读数据集；</span><br><span class="line">        <span class="built_in">P</span>(rmutex);</span><br><span class="line">        readcount--;</span><br><span class="line">        <span class="keyword">if</span>(readcount == <span class="number">0</span>) <span class="built_in">V</span>(wmutex); <span class="comment">/* 第末位读者允许写者 */</span></span><br><span class="line">        <span class="built_in">V</span>(rmutex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">writer</span>() &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="built_in">P</span>(wmutex); <span class="comment">/* 阻止其它进程（读写）进 */</span></span><br><span class="line">        写数据集;</span><br><span class="line">        <span class="built_in">V</span>(wmutex); <span class="comment">/* 允许其它进程（读写）进 */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>现有四个进程：R1，R2，W1和W2，它们共享可以存放一个数的缓冲区B。</p>
<p>进程R1每次把从键盘上读入的一个数存到缓冲区B中，供进程W1打印输出；</p>
<p>进程R2每次把从磁盘上读入的一个数存到缓冲区B中，供进程W2打印输出。</p>
<p>怎样用P、V操作协调四个并发进程的工作？</p>
<p>设信号量e，f1，f2</p>
<p>其初值分别为e=1,f1=0,f2=0     // e表示一个可用资源，f1表示R1生产的，f2表示R2生产的</p>
<p>R1:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">L:</span><br><span class="line">	P(e)</span><br><span class="line">	从键盘上读入的一个数存到缓冲区B中</span><br><span class="line">	V(f1)</span><br><span class="line">Goto L</span><br></pre></td></tr></table></figure>
<p>R2:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">L:</span><br><span class="line">	P(e)</span><br><span class="line">	从键盘上读入的一个数存到缓冲区B中</span><br><span class="line">	V(f2)</span><br><span class="line">Goto L</span><br></pre></td></tr></table></figure>
<p>W1:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">L:</span><br><span class="line">	P(f1)</span><br><span class="line">	将缓冲区B中的数据打印输出</span><br><span class="line">	V(e)</span><br><span class="line">Goto L</span><br></pre></td></tr></table></figure>
<p>W2:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">L:</span><br><span class="line">	P(f2)</span><br><span class="line">	将缓冲区B中的数据打印输出</span><br><span class="line">	V(e)</span><br><span class="line">Goto L</span><br></pre></td></tr></table></figure>
<hr>
<p>系统中有三个进程GET、PRO、PUT，如图所示，共有两个缓冲区BUF1和BUF2，</p>
<p>假设BUF1中最多可以放11个信息，现已放入了两个信息；BUF2最多可放5个信息</p>
<p>GET进程负责不断地将输入信息送入BUF1中，PRO进程负责从BUF2中读取结果并输出。</p>
<p>使用P、V操作写出正确实现GET、PRO、PUT的同步与互斥的算法</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://yongruizhang-image.oss-cn-chengdu.aliyuncs.com/img/Downloads/image-20231121204312767.png" alt="image-20231121204312767" style="zoom:50%;" /></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">semaphore empty1=<span class="number">9</span>	<span class="comment">// 空buf1的数目</span></span><br><span class="line">semaphore full1=<span class="number">2</span>	<span class="comment">// 有数据的buf1的数目</span></span><br><span class="line">semaphore empty2=<span class="number">5</span>	<span class="comment">// 空buf2的数目</span></span><br><span class="line">semaphore full2=<span class="number">0</span>	<span class="comment">// 有数据的buf2的数目</span></span><br><span class="line">semaphore mutex1=mutex2=<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="built_in">main</span>()&#123;</span><br><span class="line">    Cobegin	<span class="comment">// 并发开始</span></span><br><span class="line">        <span class="built_in">GET</span>();</span><br><span class="line">    	<span class="built_in">PRO</span>();</span><br><span class="line">    	<span class="built_in">PUT</span>();</span><br><span class="line">    Coend	<span class="comment">// 并发结束</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// GET进程</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GET</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="built_in">P</span>(empty1); <span class="comment">// wait()</span></span><br><span class="line">        <span class="built_in">P</span>(mutex1);</span><br><span class="line">        将信息送入buf1；</span><br><span class="line">        <span class="built_in">V</span>(mutex1); <span class="comment">// signal()</span></span><br><span class="line">        <span class="built_in">V</span>(full1);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// PRO进程</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PRO</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="built_in">P</span>(full1);</span><br><span class="line">        <span class="built_in">P</span>(mutex1);</span><br><span class="line">        从buf1中取出信息；</span><br><span class="line">        <span class="built_in">V</span>(mutex1);</span><br><span class="line">        <span class="built_in">V</span>(empty1);</span><br><span class="line">        <span class="built_in">P</span>(empty2);</span><br><span class="line">        <span class="built_in">P</span>(mutex2);</span><br><span class="line">        将信息送入buf2；</span><br><span class="line">        <span class="built_in">V</span>(mutex2);</span><br><span class="line">        <span class="built_in">V</span>(full2);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// PUT进程</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PUT</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">P</span>(full2);</span><br><span class="line">        <span class="built_in">P</span>(mutex2);</span><br><span class="line">        从buf2中取出信息;</span><br><span class="line">        <span class="built_in">V</span>(mutex2);</span><br><span class="line">        <span class="built_in">V</span>(empty2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="产生死锁的4个必要条件是什么？"><a href="#产生死锁的4个必要条件是什么？" class="headerlink" title="产生死锁的4个必要条件是什么？"></a>产生死锁的4个必要条件是什么？</h1><ul>
<li><p>互斥条件（资源独占条件）</p>
<p>指进程对所分配到的资源进行排它性使用，即在一段时间内某资源只由一个进程占用。如果此时还有其它进程请求该资源，则请求者只能等待，直至占有该资源的进程用毕释放</p>
</li>
<li><p>请求和保持条件（部分分配条件）</p>
<p>指进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源又已经被其它进程占有，此时请求进程阻塞，但又对自己已获得的其他资源保持不放</p>
</li>
<li><p>不剥夺条件</p>
<p>指进程已获得的资源，在未使用完之前，不能被剥夺，只能在使用完时由自己释放</p>
</li>
<li><p>循环等待条件（环路条件）</p>
<p>指发生死锁时，必然存在一个进程——资源的环形链，即进程集合${P_0, P_1, P_2, \cdots, P_n}$中的$P_0$正在等待一个$P_1$占用的资源；$P_1$正在等待$P_2$占用的资源，……，$P_n$正在等待已被$P_0$占用的资源。</p>
</li>
</ul>
<hr>
<h1 id="安全状态，银行家算法"><a href="#安全状态，银行家算法" class="headerlink" title="安全状态，银行家算法"></a>安全状态，银行家算法</h1><h2 id="安全状态实例"><a href="#安全状态实例" class="headerlink" title="安全状态实例"></a>安全状态实例</h2><p>假定系统中有三个进程P1，P2和P3，共有12台磁带机，三个进程对磁带机的需求和占有情况如下表所示：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>进 程</th>
<th>最大需求</th>
<th>已分配</th>
<th>可用</th>
</tr>
</thead>
<tbody>
<tr>
<td>P1</td>
<td>10</td>
<td>5</td>
<td>3</td>
</tr>
<tr>
<td>P2</td>
<td>4</td>
<td>2</td>
<td></td>
</tr>
<tr>
<td>P3</td>
<td>9</td>
<td>2</td>
</tr>
</tbody>
</table>
</div>
<p>T0时刻，存在一个安全序列（P2，P1，P3）或（P2，P3，P1），所以系统是安全的。</p>
<h2 id="银行家算法"><a href="#银行家算法" class="headerlink" title="银行家算法"></a>银行家算法</h2><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p>具有代表性的避免死锁算法，是Dijkstra给出的银行家算法，为实现银行家算法，系统中必须设置若干数据结构。假定系统中有$n$个进程$（P_1，P_2，\cdots，P_n）$，$m$类资源$（R_1，R_2，\cdots，R_m）$，银行家算法中使用的数据结构如下：</p>
<ul>
<li>可利用资源向量：<code>available[j] = k</code>，资源$R_j$类有k个可用</li>
<li>最大需求矩阵：<code>Max[i, j] = k</code>，进程$P_i$最大请求k个$R_j$类资源</li>
<li>分配矩阵：<code>Allocation[i, j] = k</code>，进程$P_i$分配到k个$R_j$类资源</li>
<li>需求矩阵：<code>Need[i, j] = k</code>，进程$P_i$还需要k个$R_j$类资源</li>
</ul>
<p>矩阵关系：</p>
<p><code>Need[i, j] = Max[i, j] - Allocation[i, j]</code></p>
<h3 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h3><p>设$Request_i$是进程$P_i$的请求向量，设$Request_i[j]=k$，表示进进程$P_i$请求分配$R_j$类资源$k$个。当进程$P_i$发出资源请求后，系统按<strong>如下步骤进行检查</strong>：</p>
<ol>
<li><p>如$Request_i[j]≤Need[i,j]$,转2;否则出错，因为<strong>进程申请资源量超过它申明的最大量</strong></p>
</li>
<li><p>如$Request_i[j] ≤Available[j]$,转3;否则<strong>表示资源不够</strong>,需等待。</p>
</li>
<li><p>系统试分配资源给进程$P_i$,并作如下修改：</p>
<p>$Available[j]= Available[j]- Request_i[j]$</p>
<p>$Allocation[i,j]= Allocation[i,j]+ Request_i[j]$</p>
<p>$Need[i,j]= Need[i,j]- Request_i[j]$</p>
</li>
<li><p><strong>系统执行安全性算法，检查此次资源分配后，系统是否处于安全状态</strong>。若安全,则正式进行分配,否则恢复原状态让进程Pi等待。</p>
</li>
</ol>
<blockquote>
<p>  先判断申请资源数量是否满足条件</p>
<p>  再判断申请到资源后系统是否是安全状态</p>
</blockquote>
<h2 id="试题"><a href="#试题" class="headerlink" title="试题"></a>试题</h2><p>设某系统中有4种资源，在某时刻系统中共有5个进程，进程(P0,P1,P2,P3,P4)的最大资源需求数向量和此时已分配的资源数向量分别为：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>进程</th>
<th>最大资源需求</th>
<th>当前已分配的资源</th>
</tr>
</thead>
<tbody>
<tr>
<td>P0</td>
<td>(0,0,1,2)</td>
<td>(0,0,1,2)</td>
</tr>
<tr>
<td>P1</td>
<td>(2,7,5,0)</td>
<td>(2,0,0,0)</td>
</tr>
<tr>
<td>P2</td>
<td>(6,6,5,6)</td>
<td>(0,0,3,4)</td>
</tr>
<tr>
<td>P3</td>
<td>(4,3,5,6)</td>
<td>(2,3,5,4)</td>
</tr>
<tr>
<td>P4</td>
<td>(0,6,5,2)</td>
<td>(0,3,3,2)</td>
</tr>
</tbody>
</table>
</div>
<p>系统中当前可用资源向量为（2，1，0，0），问：</p>
<ol>
<li><p>系统当前是否处于安全状态？ </p>
<p><span style="color: red">答：</span>有安全序列：$(P_0, P_3, P_4,P_1, P_1)$,所以处于安全状态</p>
</li>
<li><p>当进程P2申请（0，1，0，0）时，系统能立即满足吗？</p>
</li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://yongruizhang-image.oss-cn-chengdu.aliyuncs.com/img/Downloads/image-20231124161551160.png" alt="image-20231124161551160"></p>
<hr>
<h1 id="请解释什么是静止优先权，什么是动态优先权"><a href="#请解释什么是静止优先权，什么是动态优先权" class="headerlink" title="请解释什么是静止优先权，什么是动态优先权"></a>请解释什么是静止优先权，什么是动态优先权</h1><ul>
<li>静态优先权：优先权在创建进程时确定，且在进程的整个运行期间保持不变。一般用一个整数表示，小表示优先级高</li>
<li>动态优先权：优先权在创建进程时确定，<strong>但在进程的运行期间会发生变化</strong></li>
</ul>
<hr>
<h1 id="什么是抢占式优先权算法？"><a href="#什么是抢占式优先权算法？" class="headerlink" title="什么是抢占式优先权算法？"></a>什么是抢占式优先权算法？</h1><p>系统把处理机分配给就绪队列中优先权最高的进程，使之执行。但在其执行期间，只要出现了另一个优先权更高的进程，进程调度程序就立即停止当前进程的执行，重新将处理机资源分配给新到的优先权最高的进程。</p>
<hr>
<h1 id="在最低松弛度优先算法（LLF）中，松弛度的计算公式是什么？"><a href="#在最低松弛度优先算法（LLF）中，松弛度的计算公式是什么？" class="headerlink" title="在最低松弛度优先算法（LLF）中，松弛度的计算公式是什么？"></a>在最低松弛度优先算法（LLF）中，松弛度的计算公式是什么？</h1><p>==松弛度 = 必须完成时间 - 其本身的运行时间 - 当前时间==</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://yongruizhang-image.oss-cn-chengdu.aliyuncs.com/img/Downloads/image-20231121212233890.png" alt="image-20231121212233890" style="zoom:50%;" /></p>
<hr>
<h1 id="调度相关例题"><a href="#调度相关例题" class="headerlink" title="调度相关例题"></a>调度相关例题</h1><p>在一个单通道批处理系统中，已知一组作业的到达时间和运行时间。计算使用<strong>先到先服务</strong>和<strong>短作业优先算法</strong>时的<strong>平均周转时间</strong></p>
<blockquote>
<p>  周转时间：</p>
<p>  周转时间 = 作业完成时刻 - 作业到达时刻</p>
<p>  平均周转时间：</p>
<p>  平均周转时间 = 作业周转总时间/作业个数</p>
</blockquote>
<h2 id="先到先服务"><a href="#先到先服务" class="headerlink" title="先到先服务"></a>先到先服务</h2><p>基本思想：按照进程进入就绪队列的<strong>先后次序</strong>来分配处理机资源。一般采用<strong>非剥夺</strong>的调度方式</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://yongruizhang-image.oss-cn-chengdu.aliyuncs.com/img/Downloads/image-20231121212830696.png" alt="image-20231121212830696" style="zoom:40%;" /></p>
<h2 id="短作业优先"><a href="#短作业优先" class="headerlink" title="短作业优先"></a>短作业优先</h2><p>主要任务是从就绪队列中选出一<strong>估计运行时间最短</strong>的进程，将处理机分配给它。</p>
<h3 id="非抢占式"><a href="#非抢占式" class="headerlink" title="非抢占式"></a>非抢占式</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://yongruizhang-image.oss-cn-chengdu.aliyuncs.com/img/Downloads/image-20231121212956483.png" alt="image-20231121212956483" style="zoom:40%;" /></p>
<h3 id="抢占式"><a href="#抢占式" class="headerlink" title="抢占式"></a>抢占式</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://yongruizhang-image.oss-cn-chengdu.aliyuncs.com/img/Downloads/image-20231121215734235.png" alt="image-20231121215734235" style="zoom:50%;" /></p>
<hr>
<h1 id="存储管理应具有哪4个基本功能？"><a href="#存储管理应具有哪4个基本功能？" class="headerlink" title="存储管理应具有哪4个基本功能？"></a>存储管理应具有哪4个基本功能？</h1><ul>
<li>实现内存的分配和回收</li>
<li>地址变换（相对地址&lt;——&gt;绝对地址）</li>
<li>“扩充”内存容量</li>
<li>进行存储保护</li>
</ul>
<hr>
<h1 id="一个用户源程序要变为在内存中可执行的程序，通常要进行哪几步处理？"><a href="#一个用户源程序要变为在内存中可执行的程序，通常要进行哪几步处理？" class="headerlink" title="一个用户源程序要变为在内存中可执行的程序，通常要进行哪几步处理？"></a>一个用户源程序要变为在内存中可执行的程序，通常要进行哪几步处理？</h1><ul>
<li>编译：由编译程序将<strong>用户源程序</strong>编译成<strong>若干个目标模块</strong></li>
<li>链接：由链接程序将<strong>目标模块和相应的库函数</strong>链接成<strong>装入模块</strong></li>
<li>装入：由装入程序将<strong>装入模块装入内存</strong></li>
</ul>
<hr>
<h1 id="内存分配例题"><a href="#内存分配例题" class="headerlink" title="内存分配例题"></a>内存分配例题</h1><p>按照<strong>固定分区分配方式</strong>的分区说明表，请绘出当前的内存分配情况</p>
<h2 id="固定分区分配方式"><a href="#固定分区分配方式" class="headerlink" title="固定分区分配方式"></a>固定分区分配方式</h2><p>是最早使用的一种可运行<strong>多道程序</strong>的存储管理方法。</p>
<h3 id="存储管理办法"><a href="#存储管理办法" class="headerlink" title="存储管理办法"></a>存储管理办法</h3><ul>
<li><p><strong>内存空间的划分：</strong>将内存空间划分为若干个<strong>固定大小的分区</strong>，除OS占一区外，<strong>其余的一个分区装入一道程序</strong>。分区的大小可以相等，也可以不等，但事先必须确定，在运行时不能改变。<strong>即分区大小及边界在运行时不能改变</strong>。</p>
</li>
<li><p>系统需建立一张分区说明表或使用表，以<strong>记录分区号、分区大小、分区的起始地址及状态（已分配或未分配）</strong></p>
</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://yongruizhang-image.oss-cn-chengdu.aliyuncs.com/img/Downloads/image-20231122200000218.png" alt="image-20231122200000218" style="zoom:35%;" /></p>
<h3 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h3><ul>
<li>当某个用户程序要装入内存时<ul>
<li>由<strong>内存分配程序检索分区说明表</strong>，从表中<strong>找出一个满足要求的尚未分配的分区</strong><ul>
<li>找到的同时<strong>将分区分配给该程序并修改说明表中相应分区的状态</strong>；</li>
<li>若找不到大小足够的分区，<strong>则拒绝为该程序分配内存</strong></li>
</ul>
</li>
</ul>
</li>
<li>当程序执行完毕<ul>
<li>释放占用的分区</li>
<li>管理程序将修改说明表中相应分区的状态为未分配</li>
<li>实现内存资源的回收。</li>
</ul>
</li>
</ul>
<h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><p>在某系统中，采用固定分区分配管理方式，内存分区（单位字节）情况如图所示，现有大小为1K、9K、33K、121K的多个作业要求进入内存，试画出它们进入内存后的空间分配情况，并说明主存浪费多大？</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://yongruizhang-image.oss-cn-chengdu.aliyuncs.com/img/Downloads/image-20231122200352145.png" alt="image-20231122200352145" style="zoom:35%;" /></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://yongruizhang-image.oss-cn-chengdu.aliyuncs.com/img/Downloads/image-20231122200436048.png" alt="image-20231122200436048" style="zoom:45%;" /></p>
<hr>
<h1 id="讨论覆盖与交换技术的异同"><a href="#讨论覆盖与交换技术的异同" class="headerlink" title="讨论覆盖与交换技术的异同"></a>讨论覆盖与交换技术的异同</h1><p>覆盖与交换技术是在<strong>多道程序</strong>下<strong>扩充内存</strong>的两种方法，</p>
<p>覆盖技术<strong>要求</strong>程序员给出程序覆盖结构，交换技术<strong>不要求</strong>程序员给出覆盖结构，</p>
<p>覆盖技术主要在一个作业或进程<strong>中</strong>进行，交换主要在作业或进程<strong>之间</strong>进行。</p>
<hr>
<h1 id="什么是分页虚拟存储系统中的抖动现象？"><a href="#什么是分页虚拟存储系统中的抖动现象？" class="headerlink" title="什么是分页虚拟存储系统中的抖动现象？"></a>什么是分页虚拟存储系统中的抖动现象？</h1><p>刚被<strong>淘汰出内存的页面</strong>，过后不久<strong>又要访问它</strong>，需要再次将其调入，而该页<strong>调入内存后不久</strong>又再<strong>次被淘汰出内存</strong>，然后<strong>又要访问它</strong>，如此反复，使得<strong>系统把大部分时间用在了页面的调进转换上</strong>，而<strong>几乎不能完成任何有效工作</strong>，这种现象称为抖动（又称颠簸）</p>
<hr>
<h1 id="分页存储和段式存储逻辑地址物理地址变换典型例题"><a href="#分页存储和段式存储逻辑地址物理地址变换典型例题" class="headerlink" title="分页存储和段式存储逻辑地址物理地址变换典型例题"></a>分页存储和段式存储逻辑地址物理地址变换典型例题</h1><blockquote>
<p>  最终结果要写成十六进制</p>
</blockquote>
<h2 id="分页存储"><a href="#分页存储" class="headerlink" title="分页存储"></a>分页存储</h2><h3 id="地址结构"><a href="#地址结构" class="headerlink" title="地址结构"></a>地址结构</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://yongruizhang-image.oss-cn-chengdu.aliyuncs.com/img/Downloads/image-20231122200842097.png" alt="image-20231122200842097" style="zoom:50%;" /></p>
<h3 id="地址结构例题"><a href="#地址结构例题" class="headerlink" title="地址结构例题"></a>地址结构例题</h3><p>设有一页式存储管理系统，向用户提供的逻辑地址空间最大为16页，每页2048B，内存总共有8个存储块，试问逻辑地址至少应为多少位？内存空间有多大？</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://yongruizhang-image.oss-cn-chengdu.aliyuncs.com/img/Downloads/image-20231122201113620.png" alt="image-20231122201113620" style="zoom:50%;" /></p>
<h3 id="页表"><a href="#页表" class="headerlink" title="页表"></a>页表</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://yongruizhang-image.oss-cn-chengdu.aliyuncs.com/img/Downloads/image-20231122201506911.png" alt="image-20231122201506911" style="zoom:50%;" /></p>
<h3 id="地址变换例题"><a href="#地址变换例题" class="headerlink" title="地址变换例题"></a>地址变换例题</h3><p>若在一分页存储管理系统中，某作业的页表如表所示，已知页面大小为1024B，试将逻辑地址1011，2148，5012转化为相应的物理地址？画出其地址转换图。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th><strong>页号</strong></th>
<th><strong>块号</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>0</strong></td>
<td><strong>2</strong></td>
</tr>
<tr>
<td><strong>1</strong></td>
<td><strong>3</strong></td>
</tr>
<tr>
<td><strong>2</strong></td>
<td><strong>1</strong></td>
</tr>
<tr>
<td><strong>3</strong></td>
<td><strong>6</strong></td>
</tr>
</tbody>
</table>
</div>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://yongruizhang-image.oss-cn-chengdu.aliyuncs.com/img/Downloads/image-20231122201734956.png" alt="image-20231122201734956" style="zoom:50%;" /></p>
<h3 id="考试例题"><a href="#考试例题" class="headerlink" title="考试例题"></a>考试例题</h3><p>设有一页式存储管理系统，向用户提供的逻辑地址空间最大为32页，每页2048B，内存总共有16个存储块，页表的记录情况如下表所示，试将逻辑地址2548转换成物理地址。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>页号</th>
<th>块号</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>2</td>
</tr>
<tr>
<td>1</td>
<td>5</td>
</tr>
<tr>
<td>3</td>
<td>7</td>
</tr>
<tr>
<td>4</td>
<td>9</td>
</tr>
<tr>
<td>29</td>
<td>12</td>
</tr>
<tr>
<td>30</td>
<td>15</td>
</tr>
</tbody>
</table>
</div>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://yongruizhang-image.oss-cn-chengdu.aliyuncs.com/img/Downloads/image-20231124163052146.png" alt="image-20231124163052146" style="zoom:20%;" /></p>
<hr>
<p>某虚拟存储器的用户编程空间共32个页面，每页为1KB，内存为16KB。假定某时刻一用户页表中已调入内存的页面的页号和物理块号（十进制）的对照表如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>页号</th>
<th>物理块号</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>3</td>
</tr>
<tr>
<td>1</td>
<td>7</td>
</tr>
<tr>
<td>2</td>
<td>11</td>
</tr>
<tr>
<td>3</td>
<td>8</td>
</tr>
</tbody>
</table>
</div>
<p>则逻辑地址000 1010 0101 1100（二进制）所对应的物理地址是什么？</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://yongruizhang-image.oss-cn-chengdu.aliyuncs.com/img/Downloads/image-20231124162545235.png" alt="image-20231124162545235" style="zoom:20%;" /></p>
<hr>
<h2 id="段式存储"><a href="#段式存储" class="headerlink" title="段式存储"></a>段式存储</h2><h3 id="段表"><a href="#段表" class="headerlink" title="段表"></a>段表</h3><ul>
<li><p>记录了<strong>段</strong>与<strong>内存位置</strong>的<strong>对应</strong>关系</p>
</li>
<li><p><strong>段表</strong>常保存在<strong>内存中</strong>（或一组寄存器中）</p>
</li>
<li><p>段表的<strong>基址</strong>及<strong>长度</strong>由<strong>段表寄存器</strong>给出</p>
</li>
<li><p>访问一个字节的数据/指令需<strong>访问内存2次</strong>(段表一次,内存一次),所以也出现内存访问速度降低的问题</p>
</li>
<li>逻辑地址：<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://yongruizhang-image.oss-cn-chengdu.aliyuncs.com/img/Downloads/%E6%AE%B5%E5%8F%B7_%E6%AE%B5%E5%86%85%E5%9C%B0%E5%9D%80.png" alt="段号_段内地址" style="zoom:48%;" /></li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://yongruizhang-image.oss-cn-chengdu.aliyuncs.com/img/Downloads/%E6%AE%B5%E5%8F%B7_%E6%AE%B5%E9%95%BF_%E5%9F%BA%E5%9D%80.png" alt="段号_段长_基址" style="zoom:48%;" /></p>
<p>例：采用段式存储管理的系统中，若地址用24位表示，其中8位表示段号，则允许段的最大长度是（ <span style="color: red">B</span> ）</p>
<p>   A.$2^{24}$  B. $2^{16}$  C. $2^8$  D. $2^{32}$</p>
<h3 id="地址变换"><a href="#地址变换" class="headerlink" title="地址变换"></a>地址变换</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://yongruizhang-image.oss-cn-chengdu.aliyuncs.com/img/Downloads/IMG_F8F4AA99062F-1.jpeg" alt="IMG_F8F4AA99062F-1" style="zoom:50%;" /></p>
<h3 id="例题-1"><a href="#例题-1" class="headerlink" title="例题"></a>例题</h3><p>某段表的内容如下：</p>
<p>​        段号    段首址    段长度</p>
<p>​        0      120K      40K</p>
<p>​        1      760K      30K</p>
<p>​        2      480K      20K</p>
<p>​        3      370K      20K</p>
<p>一逻辑地址为（2154），它对应的物理地址为多少？</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://yongruizhang-image.oss-cn-chengdu.aliyuncs.com/img/Downloads/image-20231122205319277.png" alt="image-20231122205319277" style="zoom:50%;" /></p>
<hr>
<p>在一个段式存储管理系统中，其段表为：</p>
<p>​        段号   内存起始地址   段长</p>
<p>​        0        210       500</p>
<p>​        1        2350      20</p>
<p>​        2        100       90</p>
<p>​        3        1350      590</p>
<p>​        4        1938      95</p>
<p>试求表中逻辑地址对应的物理地址是什么？</p>
<div class="table-container">
<table>
<thead>
<tr>
<th><strong>0</strong></th>
<th><strong>430</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>2</strong></td>
<td><strong>120</strong></td>
</tr>
</tbody>
</table>
</div>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://yongruizhang-image.oss-cn-chengdu.aliyuncs.com/img/Downloads/image-20231122210129159.png" alt="image-20231122210129159" style="zoom:50%;" /></p>
<hr>
<h3 id="考试例题-1"><a href="#考试例题-1" class="headerlink" title="考试例题"></a>考试例题</h3><p>假设有下面的段表：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>段</th>
<th>基址</th>
<th>长度</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>219</td>
<td>600</td>
</tr>
<tr>
<td>1</td>
<td>2300</td>
<td>14</td>
</tr>
<tr>
<td>2</td>
<td>90</td>
<td>100</td>
</tr>
<tr>
<td>3</td>
<td>1327</td>
<td>580</td>
</tr>
<tr>
<td>4</td>
<td>1952</td>
<td>96</td>
</tr>
</tbody>
</table>
</div>
<p>下面逻辑地址的物理地址分别是多少？</p>
<p>a、[1,12]</p>
<p>b、[2,500]</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://yongruizhang-image.oss-cn-chengdu.aliyuncs.com/img/Downloads/image-20231124163226367.png" alt="image-20231124163226367" style="zoom:15%;" /></p>
<hr>
<h1 id="带快表页式系统存取时间计算"><a href="#带快表页式系统存取时间计算" class="headerlink" title="带快表页式系统存取时间计算"></a>带快表页式系统存取时间计算</h1><h2 id="有效访问内存的时间"><a href="#有效访问内存的时间" class="headerlink" title="有效访问内存的时间"></a>有效访问内存的时间</h2><script type="math/tex; mode=display">
T=P_{TLB}*(T_{TLB}+T_M) + (1-P_{TLB})*(T_{TLB}+2T_M)</script><p>其中，$P<em>{TLB}$为快表的命中率，$T</em>{TLB}$为快表的访问时间，$T_M$为内存的访问时间</p>
<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>有一页式系统，其页表存放在主存中。</p>
<p>（1）如果对主存的一次存取需要100ns，试问实现<strong>一次页面访问</strong>的存取时间是多少？</p>
<p>（2）如果<strong>系统加有快表</strong>，对快表的一次存取需要20ns,若平均命中率为85%，试问此时的存取时间为多少？</p>
<hr>
<p>解答：</p>
<p>（1）页表放主存中，则实现一次页面访问需2次访问主存，一次是访问页表，确定所存取页面的物理块，从而得到其物理地址，一次根据物理地址存取页面数据。（就是没有使用快表的情况）</p>
<p>所以实现一次页面访问的存取时间为：$100ns*2=200ns$</p>
<p>（2）系统加有快表，根据公式，则实现一次页面访问的存取时间为：</p>
<p>$0.85<em>(20ns+100ns)+(1-0.85)</em>(20ns+2*100ns)=135ns$</p>
<hr>
<h1 id="页面置换算法典型例题"><a href="#页面置换算法典型例题" class="headerlink" title="页面置换算法典型例题"></a>页面置换算法典型例题</h1><blockquote>
<p>  画表格</p>
</blockquote>
<p>对于如下的页面访问序列：1，2，3，4，1，2，5，1，2，3，4，5。当内存块数量为3时试问：使用FIFO、LRU置换算法产生的缺页中断是多少？写出一次产生缺页中断后应淘汰的页。（画表格）</p>
<h2 id="FIFO（先进先出置换算法）"><a href="#FIFO（先进先出置换算法）" class="headerlink" title="FIFO（先进先出置换算法）"></a>FIFO（先进先出置换算法）</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://yongruizhang-image.oss-cn-chengdu.aliyuncs.com/img/Downloads/image-20231122210821198.png" alt="image-20231122210821198" style="zoom:50%;" /></p>
<h2 id="LRU（最近最久未使用算法）"><a href="#LRU（最近最久未使用算法）" class="headerlink" title="LRU（最近最久未使用算法）"></a>LRU（最近最久未使用算法）</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://yongruizhang-image.oss-cn-chengdu.aliyuncs.com/img/Downloads/image-20231122211029223.png" alt="image-20231122211029223" style="zoom:50%;" /></p>
<hr>
<h1 id="什么是设备控制器？"><a href="#什么是设备控制器？" class="headerlink" title="什么是设备控制器？"></a>什么是设备控制器？</h1><p>处于CPU与I/O设备之间的<strong>接口</strong>，接收CPU发来的命令，并控制I/O设备工作，是一个可编址设备</p>
<hr>
<h1 id="在设备管理中主要使用哪四种输入-输出控制方式？"><a href="#在设备管理中主要使用哪四种输入-输出控制方式？" class="headerlink" title="在设备管理中主要使用哪四种输入/输出控制方式？"></a>在设备管理中主要使用哪四种输入/输出控制方式？</h1><p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://blog.csdn.net/weixin_45792450/article/details/109486061#:~:text=I%2FO控制的方式主要有四种：%20直接控制%20，%20中断驱动%20，,DMA方式%20%28Direct%20Memory%20Access%29%20，%20通道控制">解释1</a></p>
<ul>
<li><p>程序直接控制方式</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://yongruizhang-image.oss-cn-chengdu.aliyuncs.com/img/Downloads/image-20231122211510074.png" alt="image-20231122211510074" style="zoom:50%;" /></p>
</li>
<li><p>中断控制方式</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://yongruizhang-image.oss-cn-chengdu.aliyuncs.com/img/Downloads/image-20231122211531531.png" alt="image-20231122211531531" style="zoom:50%;" /></p>
</li>
<li><p>直接存储器访问（DMA）方式</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://yongruizhang-image.oss-cn-chengdu.aliyuncs.com/img/Downloads/image-20231122211556193.png" alt="image-20231122211556193" style="zoom:50%;" /></p>
</li>
<li><p>通道控制方式</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://yongruizhang-image.oss-cn-chengdu.aliyuncs.com/img/Downloads/image-20231122211615035.png" alt="image-20231122211615035" style="zoom:50%;" /></p>
</li>
</ul>
<pre><code>1.   **程序直接控制方式**：在早期的计算机中，由于无中断机构，**处理机对I/O设备的控制采用程序直接控制方式**，或称为忙-等待方式。这种方式虽然简单易于实现，但是其缺点也是显而易见的，由于CPU和I/O设备**只能串行工作**，**导致**CPU的利用率相当低

2.   **中断控制方式**：中断控制方式的思想是，**允许I/O设备主动打断CPU的运行并请求服务**，从而“解放”CPU，使得CPU向I/O控制器发送读命令后可以继续做其他有用的工作，CPU与I/O可以并行操作

3.   **DMA方式**：DMA（直接存储器存取）方式的基本思想是在I/O设备和内存**之间**开辟直接的数据交换通路，彻底“解放” CPU。DMA方式的特点是：**基本单位是数据块**。所传送的数据，是从设备直接送入内存的，或者相反（数据从内存直接送入设备）。仅在传送一个或多个数据块的开始和结束时，才需CPU干预，**整块数据的传送是在DMA控制器的控制下完成的**

4.   **通道控制方式**：**I/O通道是指专门负责输入/输出的处理机**。I/O通道方式是DMA方式的发展，它可以进一步减少CPU的干预，即把对**一个**数据块的读（或写）为单位的干预，减少为对**一组**数据块的读（或写）**及有关的控制和管理**为单位的干预
</code></pre><hr>
<h1 id="在设备分配中需要使用哪四种基本数据结构？"><a href="#在设备分配中需要使用哪四种基本数据结构？" class="headerlink" title="在设备分配中需要使用哪四种基本数据结构？"></a>在设备分配中需要使用哪四种基本数据结构？</h1><ul>
<li>设备控制表DCT</li>
<li>控制器控制表COCT</li>
<li>通道控制表CHCT</li>
<li>系统设备表SDT</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://yongruizhang-image.oss-cn-chengdu.aliyuncs.com/img/Downloads/image-20231122211734406.png" alt="image-20231122211734406" style="zoom:45%;" /></p>
<hr>
<h1 id="设备驱动程序有哪些基本功能？"><a href="#设备驱动程序有哪些基本功能？" class="headerlink" title="设备驱动程序有哪些基本功能？"></a>设备驱动程序有哪些基本功能？</h1><ul>
<li><p>将接收到的<strong>抽象要求</strong>转换为<strong>具体要求</strong></p>
</li>
<li><p>检查用户I/O请求的合法性，I/O设备状态，传参数，设设备的工作方式</p>
</li>
<li><p>按处理机的I/O请求去启动指定的设备进行I/O操作</p>
</li>
<li><p>及时响应由<strong>控制器或通知</strong>发来的<strong>中断请求</strong>，并进行相应处理</p>
</li>
<li><p>按I/O请求构成相应通道程序</p>
</li>
</ul>
<hr>
<h1 id="什么是虚拟设备？"><a href="#什么是虚拟设备？" class="headerlink" title="什么是虚拟设备？"></a>什么是虚拟设备？</h1><p>虚拟设备：指<strong>通过虚拟技术</strong>将一台<strong>独占设备</strong>变换为若干台逻辑设备，供若干个用户进程同时使用，通常把这种<strong>经过虚拟技术处理后的设备</strong>称为虚拟设备</p>
<hr>
<h1 id="缓冲数据处理时间计算例题"><a href="#缓冲数据处理时间计算例题" class="headerlink" title="缓冲数据处理时间计算例题"></a>缓冲数据处理时间计算例题</h1><h2 id="双缓冲一块数据的处理时间"><a href="#双缓冲一块数据的处理时间" class="headerlink" title="双缓冲一块数据的处理时间"></a>双缓冲一块数据的处理时间</h2><p>系统处理一块数据的时间可以粗略地认为是$Max(C, T)$。</p>
<p>如果$C<T$，可使块设备连续输入；如果$C>T$，则可使CPU不必等待设备输入。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://yongruizhang-image.oss-cn-chengdu.aliyuncs.com/img/Downloads/image-20231122212356911.png" alt="image-20231122212356911" style="zoom:50%;" /></p>
<h2 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h2><p>在某系统中，<strong>从磁盘</strong>将一块数据输入到缓冲区需要花费的时间$T=100ms$，CPU对一块数据进行处理的时间为$C=5ms$，<strong>将缓冲区</strong>的数据传送<strong>到用户区</strong>所花时间为$M=10ms$，那么在<strong>双缓冲</strong>情况下，系统处理大量数据时，一块数据的处理时间为多少？</p>
<p><span style="color: red">答：</span>因为$C&lt;T$,所以处理时间为：$MAX(C, T) = T = 100ms$</p>
<hr>
<h1 id="磁盘寻道算法例题"><a href="#磁盘寻道算法例题" class="headerlink" title="磁盘寻道算法例题"></a>磁盘寻道算法例题</h1><h2 id="SSTF（最短寻道时间优先）"><a href="#SSTF（最短寻道时间优先）" class="headerlink" title="SSTF（最短寻道时间优先）"></a>SSTF（最短寻道时间优先）</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://yongruizhang-image.oss-cn-chengdu.aliyuncs.com/img/Downloads/image-20231122212920516.png" alt="image-20231122212920516" style="zoom:45%;" /></p>
<h2 id="FCFS（先来先服务）"><a href="#FCFS（先来先服务）" class="headerlink" title="FCFS（先来先服务）"></a>FCFS（先来先服务）</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://yongruizhang-image.oss-cn-chengdu.aliyuncs.com/img/Downloads/image-20231122213054764.png" alt="image-20231122213054764" style="zoom:45%;" /></p>
<h2 id="SCAN（扫描算法）"><a href="#SCAN（扫描算法）" class="headerlink" title="SCAN（扫描算法）"></a>SCAN（扫描算法）</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://yongruizhang-image.oss-cn-chengdu.aliyuncs.com/img/Downloads/image-20231122213545211.png" alt="image-20231122213545211" style="zoom:50%;" /></p>
<p>没说方向就是先往右再往左。</p>
<h2 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h2><p>设某磁盘有200个柱面，编号为0，1，2，…,199。磁头停在100号磁道，若9个磁盘按到达时间的先后排成的等待服务队列为：55，58，39，18，90，160，150，38，184，采用<strong>最短寻道时间优先SSTF磁盘调度算法</strong>，<strong>FCFS</strong>和<strong>SCAN磁盘寻道调度算法</strong>。</p>
<p>试画出寻道图，求磁道响应请求道次序。求总磁头移动量，磁头的平均寻道长度。</p>
<p>最短寻道时间优先SSTF：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://yongruizhang-image.oss-cn-chengdu.aliyuncs.com/img/Downloads/image-20231124163441052.png" alt="image-20231124163441052" style="zoom:35%;" /></p>
<p>FCFS：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://yongruizhang-image.oss-cn-chengdu.aliyuncs.com/img/Downloads/image-20231124163535462.png" alt="image-20231124163535462" style="zoom:35%;" /></p>
<p>SCAN：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://yongruizhang-image.oss-cn-chengdu.aliyuncs.com/img/Downloads/image-20231124163825739.png" alt="image-20231124163825739" style="zoom:35%;" /></p>
<hr>
<h1 id="索引逻辑结构文件的优缺点"><a href="#索引逻辑结构文件的优缺点" class="headerlink" title="索引逻辑结构文件的优缺点"></a>索引逻辑结构文件的优缺点</h1><ul>
<li>优点<ul>
<li>通过索引表可方便地实现直接存取，具有较快的检索速度</li>
<li>易于进行文件的增删</li>
</ul>
</li>
<li>缺点<ul>
<li>索引表的使用增加了存储费用</li>
<li>索引表的查找策略对文件系统的效率影响很大</li>
</ul>
</li>
</ul>
<hr>
<h1 id="有哪三种常见的外存分配方法？"><a href="#有哪三种常见的外存分配方法？" class="headerlink" title="有哪三种常见的外存分配方法？"></a>有哪三种常见的外存分配方法？</h1><ul>
<li>连续分配（顺序分配）<ul>
<li>为<strong>每一个文件</strong>分配一片<strong>连续</strong>的磁盘块/簇</li>
<li>只需要<strong>起始块/簇号</strong>和<strong>长度</strong>，适用于预分配方法</li>
<li>可以<strong>随机存取</strong></li>
<li>文件不能增长</li>
<li>从逻辑地址映射到物理地址较简单</li>
<li>浪费空间：动态存储分配问题</li>
<li>可以通过紧缩(compact)将外存空闲空间合并成连续的区域。</li>
</ul>
</li>
<li>链接分配<ul>
<li>每个文件是一个磁盘块的链接列表：块可以<strong>分散</strong>在磁盘各处</li>
<li>按所需分配磁盘块，<strong>链接</strong>在一起</li>
<li>在每个块中有指向下一个块的<strong>指针</strong></li>
<li>只需要起始地址</li>
<li>可以通过<strong>合并(consolidation)</strong>将一个文件的各个簇连续存放，以提高I/O访问性能。</li>
</ul>
</li>
<li><p>索引分配</p>
<ul>
<li>为每一个文件分配一个索引块（表），再把分配给该文件的所有<strong>块号</strong>，<strong>都记录在该索引块中</strong>。故索引块就是一个含有许多块号地址的数组</li>
<li>该索引块的地址由该文件的目录项指出</li>
<li>支持随机/直接存取</li>
<li>不会产生外部碎片</li>
<li>适用于文件较大时</li>
</ul>
</li>
<li><p><strong>连续分配</strong>：为每个文件分配一片连续的磁盘块，只需起始块号和长度，适用于预分配方法，可以随机存取，但文件不能增长。</p>
</li>
<li><strong>链接分配</strong>：每个文件是一个磁盘块的链接列表，按需分配磁盘块并链接在一起，在每个块中有指向下一个块的<strong>指针</strong>，只需起始地址。</li>
<li><strong>索引分配</strong>：为每个文件分配一个索引块，记录所有分配给该文件的块号，故索引块就是一个含有许多块号地址的数组，支持随机存取，适用于大文件。</li>
</ul>
<hr>
<h1 id="文件目录管理有哪些基本要求？"><a href="#文件目录管理有哪些基本要求？" class="headerlink" title="文件目录管理有哪些基本要求？"></a>文件目录管理有哪些基本要求？</h1><ul>
<li>实现“按名存取”</li>
<li>提高对目录的<strong>检索速度</strong></li>
<li>文件共享</li>
<li>允许文件重名</li>
</ul>
<hr>
<h1 id="请解释什么是目录文件？"><a href="#请解释什么是目录文件？" class="headerlink" title="请解释什么是目录文件？"></a>请解释什么是目录文件？</h1><p>为了实现对<strong>文件目录</strong>的管理，通常将文件目录以<strong>文件的形式</strong>保存在<strong>外存</strong>，<strong>这个文件</strong>就叫做目录文件。</p>
<hr>
<h1 id="FAT容量计算"><a href="#FAT容量计算" class="headerlink" title="FAT容量计算"></a>FAT容量计算</h1><p>软盘（或硬盘）容量/ 盘块大小 = 盘块个数。</p>
<p>比盘块个数大的最小的2的n次方，表项有n/8个字节</p>
<p>表项个数*表项所占字节数 = FAT所占空间</p>
<h2 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h2><p>假定磁盘块大小为2KB，对于20G的硬盘，计算其文件分配表FAT占用的空间  <span style="color: red">30MB</span></p>
<script type="math/tex; mode=display">
\text{盘块数} = \frac{20\;GB}{2\;KB} = \frac{20 * 1024 * 1024\;KB}{2\;KB} = 10 * 1024*1024个=10*2^{20}个 \\
2^{23} < 10*2^{20} < 2^{24} => \text{表项大小} = 24位 = 24/8 = 3字节 \\
\text{FAT所占空间} = \text{表项个数（盘块个数）}*\text{表项大小（表项所占字节）} = 30 * 2^{20} B = 30MB</script><hr>
<p>假定盘块的大小为4KB，硬盘的大小为12GB，计算：</p>
<ol>
<li>硬盘应共有多少个盘块  <span style="color: red">3MB</span></li>
</ol>
<script type="math/tex; mode=display">
\frac{12\;GB}{4\;KB} = \frac{12*1024\;KB}{4\;KB} = 3 * 1024\;KB = 3\;MB = 3145728个盘快</script><ol>
<li>FAT的每个表项有多少个字节  <span style="color: red">2.75B</span></li>
</ol>
<p>对于FAT12文件系统来说，每个表项有1.5个字节</p>
<p>对于FAT16文件系统来说，每个表项有2个字节</p>
<p>对于FAT32文件系统来说，每个表项有4个字节</p>
<p>通过题目中计算：</p>
<script type="math/tex; mode=display">
2^{21} < 3*2^{20} < 2^{22}</script><p>因此每个表项有$22/8=2.75$个字节</p>
<ol>
<li>FAT需占用多少存储空间  <span style="color: red">8.25MB</span></li>
</ol>
<p>对于FAT12文件系统来说，1.5*3MB=4.5MB</p>
<p>对于FAT16文件系统来说，2*3MB=6MB</p>
<p>对于FAT32文件系统来说，4*3MB=12MB</p>
<p>通过题目中计算：</p>
<script type="math/tex; mode=display">
3*1024*2.75\;B=8.25*1024\;B = 8.25\;MB</script></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://yongruizhang.cn">YongRui Zhang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://yongruizhang.cn/posts/2959474469.html">http://yongruizhang.cn/posts/2959474469.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://yongruizhang.cn" target="_blank">秋白's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">计算机操作系统</a></div><div class="post_share"><div class="social-share" data-image="https://yongruizhang-image.oss-cn-chengdu.aliyuncs.com/img/img127.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://yongruizhang-image.oss-cn-chengdu.aliyuncs.com/img/Downloads/weixin.jpeg" rel="external nofollow noreferrer" target="_blank"><img class="post-qr-code-img" src="https://yongruizhang-image.oss-cn-chengdu.aliyuncs.com/img/Downloads/weixin.jpeg" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="https://yongruizhang-image.oss-cn-chengdu.aliyuncs.com/img/Downloads/alipay.jpeg" rel="external nofollow noreferrer" target="_blank"><img class="post-qr-code-img" src="https://yongruizhang-image.oss-cn-chengdu.aliyuncs.com/img/Downloads/alipay.jpeg" alt="alipay"/></a><div class="post-qr-code-desc">alipay</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/2864584994.html" title="重定向输入"><img class="cover" src="https://yongruizhang-image.oss-cn-chengdu.aliyuncs.com/img/Downloads/img.jpg" onerror="onerror=null;src='https://yongruizhang-image.oss-cn-chengdu.aliyuncs.com/img/Downloads/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">重定向输入</div></div></a></div><div class="next-post pull-right"><a href="/posts/765481613.html" title="KMP算法"><img class="cover" src="https://zyr-blog-image.oss-cn-beijing.aliyuncs.com/img101.jpg" onerror="onerror=null;src='https://yongruizhang-image.oss-cn-chengdu.aliyuncs.com/img/Downloads/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">KMP算法</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://yongruizhang-image.oss-cn-chengdu.aliyuncs.com/img/Downloads/favicon.png" onerror="this.onerror=null;this.src='https://yongruizhang-image.oss-cn-chengdu.aliyuncs.com/img/Downloads/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">秋白</div><div class="author-info__description">埋头学习 抬头恋爱</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">119</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">64</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">78</div></a></div><a id="card-info-btn" target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/yongruizhang"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/yongruizhang" rel="external nofollow noreferrer" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:yongruizhang@gmail.com" rel="external nofollow noreferrer" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="https://space.bilibili.com/367319940?spm_id_from=333.337.0.0" rel="external nofollow noreferrer" target="_blank" title="bilibili"><i class="fa-brands fa-bilibili"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content"><p style="text-indent:2em;">我是数据科学与大数据专业本科生。<br/></p><p style="text-indent:2em;">目前主要学习AR、CV、大数据开发，数学建模，机器学习，算法。之前浅学过Java后端，有一点前端基础。<br/></p><p style="text-indent:2em;">为了您的体验，没有设置复制权限，您可以复制文章内容和代码来做笔记等，但您要发布文章请注明内容出处，请遵循开源原则🤝</p><p style="text-indent:2em;">如果文章内容有错误，或者版本等问题拜托在评论区留言，为后来人搭桥。感谢🙏</p><p style="text-indent:2em;">由于我是利用电脑端Safari浏览器写的相关样式，所以不同平台的效果可能不同，不推荐使用手机访问博客（我没怎么适配，可能会有些显示问题）。前端技术有限😅<br/></p></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%9F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BD%9C%E7%94%A8%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-text">什么是操作系统？操作系统的作用有哪些</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8%EF%BC%9A"><span class="toc-text">作用：</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%80%9A%E5%B8%B8%E5%85%B7%E6%9C%89%E5%93%AA4%E4%B8%AA%E5%9F%BA%E6%9C%AC%E7%89%B9%E5%BE%81"><span class="toc-text">操作系统通常具有哪4个基本特征</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%BA%94%E5%AE%9E%E7%8E%B0%E5%93%AA%E4%BA%9B%E5%9F%BA%E6%9C%AC%E7%9B%AE%E6%A0%87"><span class="toc-text">操作系统应实现哪些基本目标</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8A%9F%E8%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-text">操作系统的基本功能有哪些</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E6%9C%BA%E7%AE%A1%E7%90%86%E5%8A%9F%E8%83%BD"><span class="toc-text">处理机管理功能</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E5%99%A8%E7%AE%A1%E7%90%86%E5%8A%9F%E8%83%BD"><span class="toc-text">存储器管理功能</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86%E5%8A%9F%E8%83%BD"><span class="toc-text">设备管理功能</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86%E5%8A%9F%E8%83%BD"><span class="toc-text">文件管理功能</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E6%8E%A5%E5%8F%A3%E7%AE%A1%E7%90%86%E7%9A%84%E5%8A%9F%E8%83%BD"><span class="toc-text">用户接口管理的功能</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E9%80%9A%E7%94%A8%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%9F"><span class="toc-text">什么是通用操作系统？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A0%B9%E6%8D%AE%E7%A8%8B%E5%BA%8F%E6%AE%B5%E7%BB%98%E5%88%B6%E8%AF%AD%E5%8F%A5%E7%9A%84%E5%89%8D%E9%A9%B1%E5%9B%BE"><span class="toc-text">根据程序段绘制语句的前驱图</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AE%80%E8%A6%81%E6%8F%8F%E8%BF%B0%E7%A8%8B%E5%BA%8F%E5%92%8C%E8%BF%9B%E7%A8%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">简要描述程序和进程之间的区别</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AF%B7%E7%AE%80%E8%A6%81%E6%8F%8F%E8%BF%B0%E8%BF%9B%E7%A8%8B%E7%9A%843%E7%A7%8D%E5%9F%BA%E6%9C%AC%E7%8A%B6%E6%80%81"><span class="toc-text">请简要描述进程的3种基本状态</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E4%B8%89%E7%A7%8D%E5%9F%BA%E6%9C%AC%E7%8A%B6%E6%80%81%E7%9A%84%E8%BD%AC%E6%8D%A2%E5%9B%BE"><span class="toc-text">进程三种基本状态的转换图</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%88%9B%E5%BB%BA%E7%9A%84%E6%B5%81%E7%A8%8B%E5%9B%BE"><span class="toc-text">进程创建的流程图</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6%E5%BA%94%E5%BD%93%E9%81%B5%E5%BE%AA%E5%93%AA%E4%BA%9B%E8%A7%84%E5%88%99"><span class="toc-text">同步机制应当遵循哪些规则</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E%E4%BF%A1%E5%8F%B7%E9%87%8F%E7%9A%84%E5%85%B8%E5%9E%8B%E4%BE%8B%E9%A2%98"><span class="toc-text">关于信号量的典型例题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%BB%E8%80%85-%E5%86%99%E8%80%85%E9%97%AE%E9%A2%98"><span class="toc-text">读者-写者问题</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%A7%E7%94%9F%E6%AD%BB%E9%94%81%E7%9A%844%E4%B8%AA%E5%BF%85%E8%A6%81%E6%9D%A1%E4%BB%B6%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">产生死锁的4个必要条件是什么？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AE%89%E5%85%A8%E7%8A%B6%E6%80%81%EF%BC%8C%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%95"><span class="toc-text">安全状态，银行家算法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%89%E5%85%A8%E7%8A%B6%E6%80%81%E5%AE%9E%E4%BE%8B"><span class="toc-text">安全状态实例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%95"><span class="toc-text">银行家算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-text">数据结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E6%B5%81%E7%A8%8B"><span class="toc-text">算法流程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%95%E9%A2%98"><span class="toc-text">试题</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AF%B7%E8%A7%A3%E9%87%8A%E4%BB%80%E4%B9%88%E6%98%AF%E9%9D%99%E6%AD%A2%E4%BC%98%E5%85%88%E6%9D%83%EF%BC%8C%E4%BB%80%E4%B9%88%E6%98%AF%E5%8A%A8%E6%80%81%E4%BC%98%E5%85%88%E6%9D%83"><span class="toc-text">请解释什么是静止优先权，什么是动态优先权</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%8A%A2%E5%8D%A0%E5%BC%8F%E4%BC%98%E5%85%88%E6%9D%83%E7%AE%97%E6%B3%95%EF%BC%9F"><span class="toc-text">什么是抢占式优先权算法？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9C%A8%E6%9C%80%E4%BD%8E%E6%9D%BE%E5%BC%9B%E5%BA%A6%E4%BC%98%E5%85%88%E7%AE%97%E6%B3%95%EF%BC%88LLF%EF%BC%89%E4%B8%AD%EF%BC%8C%E6%9D%BE%E5%BC%9B%E5%BA%A6%E7%9A%84%E8%AE%A1%E7%AE%97%E5%85%AC%E5%BC%8F%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">在最低松弛度优先算法（LLF）中，松弛度的计算公式是什么？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%B0%83%E5%BA%A6%E7%9B%B8%E5%85%B3%E4%BE%8B%E9%A2%98"><span class="toc-text">调度相关例题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%88%E5%88%B0%E5%85%88%E6%9C%8D%E5%8A%A1"><span class="toc-text">先到先服务</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9F%AD%E4%BD%9C%E4%B8%9A%E4%BC%98%E5%85%88"><span class="toc-text">短作业优先</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%9E%E6%8A%A2%E5%8D%A0%E5%BC%8F"><span class="toc-text">非抢占式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%A2%E5%8D%A0%E5%BC%8F"><span class="toc-text">抢占式</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E5%BA%94%E5%85%B7%E6%9C%89%E5%93%AA4%E4%B8%AA%E5%9F%BA%E6%9C%AC%E5%8A%9F%E8%83%BD%EF%BC%9F"><span class="toc-text">存储管理应具有哪4个基本功能？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E4%B8%AA%E7%94%A8%E6%88%B7%E6%BA%90%E7%A8%8B%E5%BA%8F%E8%A6%81%E5%8F%98%E4%B8%BA%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E5%8F%AF%E6%89%A7%E8%A1%8C%E7%9A%84%E7%A8%8B%E5%BA%8F%EF%BC%8C%E9%80%9A%E5%B8%B8%E8%A6%81%E8%BF%9B%E8%A1%8C%E5%93%AA%E5%87%A0%E6%AD%A5%E5%A4%84%E7%90%86%EF%BC%9F"><span class="toc-text">一个用户源程序要变为在内存中可执行的程序，通常要进行哪几步处理？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E4%BE%8B%E9%A2%98"><span class="toc-text">内存分配例题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%BA%E5%AE%9A%E5%88%86%E5%8C%BA%E5%88%86%E9%85%8D%E6%96%B9%E5%BC%8F"><span class="toc-text">固定分区分配方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E5%8A%9E%E6%B3%95"><span class="toc-text">存储管理办法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D"><span class="toc-text">内存分配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%8B%E9%A2%98"><span class="toc-text">例题</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AE%A8%E8%AE%BA%E8%A6%86%E7%9B%96%E4%B8%8E%E4%BA%A4%E6%8D%A2%E6%8A%80%E6%9C%AF%E7%9A%84%E5%BC%82%E5%90%8C"><span class="toc-text">讨论覆盖与交换技术的异同</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%88%86%E9%A1%B5%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84%E6%8A%96%E5%8A%A8%E7%8E%B0%E8%B1%A1%EF%BC%9F"><span class="toc-text">什么是分页虚拟存储系统中的抖动现象？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%88%86%E9%A1%B5%E5%AD%98%E5%82%A8%E5%92%8C%E6%AE%B5%E5%BC%8F%E5%AD%98%E5%82%A8%E9%80%BB%E8%BE%91%E5%9C%B0%E5%9D%80%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80%E5%8F%98%E6%8D%A2%E5%85%B8%E5%9E%8B%E4%BE%8B%E9%A2%98"><span class="toc-text">分页存储和段式存储逻辑地址物理地址变换典型例题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E9%A1%B5%E5%AD%98%E5%82%A8"><span class="toc-text">分页存储</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%B0%E5%9D%80%E7%BB%93%E6%9E%84"><span class="toc-text">地址结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%B0%E5%9D%80%E7%BB%93%E6%9E%84%E4%BE%8B%E9%A2%98"><span class="toc-text">地址结构例题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%B5%E8%A1%A8"><span class="toc-text">页表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%B0%E5%9D%80%E5%8F%98%E6%8D%A2%E4%BE%8B%E9%A2%98"><span class="toc-text">地址变换例题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%80%83%E8%AF%95%E4%BE%8B%E9%A2%98"><span class="toc-text">考试例题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AE%B5%E5%BC%8F%E5%AD%98%E5%82%A8"><span class="toc-text">段式存储</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AE%B5%E8%A1%A8"><span class="toc-text">段表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%B0%E5%9D%80%E5%8F%98%E6%8D%A2"><span class="toc-text">地址变换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%8B%E9%A2%98-1"><span class="toc-text">例题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%80%83%E8%AF%95%E4%BE%8B%E9%A2%98-1"><span class="toc-text">考试例题</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B8%A6%E5%BF%AB%E8%A1%A8%E9%A1%B5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%AD%98%E5%8F%96%E6%97%B6%E9%97%B4%E8%AE%A1%E7%AE%97"><span class="toc-text">带快表页式系统存取时间计算</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%89%E6%95%88%E8%AE%BF%E9%97%AE%E5%86%85%E5%AD%98%E7%9A%84%E6%97%B6%E9%97%B4"><span class="toc-text">有效访问内存的时间</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE"><span class="toc-text">题目</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95%E5%85%B8%E5%9E%8B%E4%BE%8B%E9%A2%98"><span class="toc-text">页面置换算法典型例题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#FIFO%EF%BC%88%E5%85%88%E8%BF%9B%E5%85%88%E5%87%BA%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95%EF%BC%89"><span class="toc-text">FIFO（先进先出置换算法）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LRU%EF%BC%88%E6%9C%80%E8%BF%91%E6%9C%80%E4%B9%85%E6%9C%AA%E4%BD%BF%E7%94%A8%E7%AE%97%E6%B3%95%EF%BC%89"><span class="toc-text">LRU（最近最久未使用算法）</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E8%AE%BE%E5%A4%87%E6%8E%A7%E5%88%B6%E5%99%A8%EF%BC%9F"><span class="toc-text">什么是设备控制器？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9C%A8%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86%E4%B8%AD%E4%B8%BB%E8%A6%81%E4%BD%BF%E7%94%A8%E5%93%AA%E5%9B%9B%E7%A7%8D%E8%BE%93%E5%85%A5-%E8%BE%93%E5%87%BA%E6%8E%A7%E5%88%B6%E6%96%B9%E5%BC%8F%EF%BC%9F"><span class="toc-text">在设备管理中主要使用哪四种输入&#x2F;输出控制方式？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9C%A8%E8%AE%BE%E5%A4%87%E5%88%86%E9%85%8D%E4%B8%AD%E9%9C%80%E8%A6%81%E4%BD%BF%E7%94%A8%E5%93%AA%E5%9B%9B%E7%A7%8D%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9F"><span class="toc-text">在设备分配中需要使用哪四种基本数据结构？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F%E6%9C%89%E5%93%AA%E4%BA%9B%E5%9F%BA%E6%9C%AC%E5%8A%9F%E8%83%BD%EF%BC%9F"><span class="toc-text">设备驱动程序有哪些基本功能？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E8%99%9A%E6%8B%9F%E8%AE%BE%E5%A4%87%EF%BC%9F"><span class="toc-text">什么是虚拟设备？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BC%93%E5%86%B2%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E6%97%B6%E9%97%B4%E8%AE%A1%E7%AE%97%E4%BE%8B%E9%A2%98"><span class="toc-text">缓冲数据处理时间计算例题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8C%E7%BC%93%E5%86%B2%E4%B8%80%E5%9D%97%E6%95%B0%E6%8D%AE%E7%9A%84%E5%A4%84%E7%90%86%E6%97%B6%E9%97%B4"><span class="toc-text">双缓冲一块数据的处理时间</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE-1"><span class="toc-text">题目</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%A3%81%E7%9B%98%E5%AF%BB%E9%81%93%E7%AE%97%E6%B3%95%E4%BE%8B%E9%A2%98"><span class="toc-text">磁盘寻道算法例题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#SSTF%EF%BC%88%E6%9C%80%E7%9F%AD%E5%AF%BB%E9%81%93%E6%97%B6%E9%97%B4%E4%BC%98%E5%85%88%EF%BC%89"><span class="toc-text">SSTF（最短寻道时间优先）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#FCFS%EF%BC%88%E5%85%88%E6%9D%A5%E5%85%88%E6%9C%8D%E5%8A%A1%EF%BC%89"><span class="toc-text">FCFS（先来先服务）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SCAN%EF%BC%88%E6%89%AB%E6%8F%8F%E7%AE%97%E6%B3%95%EF%BC%89"><span class="toc-text">SCAN（扫描算法）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE-2"><span class="toc-text">题目</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84%E6%96%87%E4%BB%B6%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-text">索引逻辑结构文件的优缺点</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9C%89%E5%93%AA%E4%B8%89%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%9A%84%E5%A4%96%E5%AD%98%E5%88%86%E9%85%8D%E6%96%B9%E6%B3%95%EF%BC%9F"><span class="toc-text">有哪三种常见的外存分配方法？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86%E6%9C%89%E5%93%AA%E4%BA%9B%E5%9F%BA%E6%9C%AC%E8%A6%81%E6%B1%82%EF%BC%9F"><span class="toc-text">文件目录管理有哪些基本要求？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AF%B7%E8%A7%A3%E9%87%8A%E4%BB%80%E4%B9%88%E6%98%AF%E7%9B%AE%E5%BD%95%E6%96%87%E4%BB%B6%EF%BC%9F"><span class="toc-text">请解释什么是目录文件？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#FAT%E5%AE%B9%E9%87%8F%E8%AE%A1%E7%AE%97"><span class="toc-text">FAT容量计算</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE-3"><span class="toc-text">题目</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/4223662913.html" title="iPad找电子书教程"><img src="https://yongruizhang-image.oss-cn-chengdu.aliyuncs.com/img/Downloads/mac2.jpg" onerror="this.onerror=null;this.src='https://yongruizhang-image.oss-cn-chengdu.aliyuncs.com/img/Downloads/404.jpg'" alt="iPad找电子书教程"/></a><div class="content"><a class="title" href="/posts/4223662913.html" title="iPad找电子书教程">iPad找电子书教程</a><time datetime="2024-02-26T13:23:42.000Z" title="发表于 2024-02-26 21:23:42">2024-02-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/2768249503.html" title="2023年第十四届蓝桥杯省赛C/C++B组题解"><img src="https://yongruizhang-image.oss-cn-chengdu.aliyuncs.com/img/Downloads/img112.jpg" onerror="this.onerror=null;this.src='https://yongruizhang-image.oss-cn-chengdu.aliyuncs.com/img/Downloads/404.jpg'" alt="2023年第十四届蓝桥杯省赛C/C++B组题解"/></a><div class="content"><a class="title" href="/posts/2768249503.html" title="2023年第十四届蓝桥杯省赛C/C++B组题解">2023年第十四届蓝桥杯省赛C/C++B组题解</a><time datetime="2024-02-21T13:55:35.000Z" title="发表于 2024-02-21 21:55:35">2024-02-21</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/2697614349.html" title="树上前缀和及树上差分"><img src="https://yongruizhang-image.oss-cn-chengdu.aliyuncs.com/img/img128.png" onerror="this.onerror=null;this.src='https://yongruizhang-image.oss-cn-chengdu.aliyuncs.com/img/Downloads/404.jpg'" alt="树上前缀和及树上差分"/></a><div class="content"><a class="title" href="/posts/2697614349.html" title="树上前缀和及树上差分">树上前缀和及树上差分</a><time datetime="2024-02-21T12:31:53.000Z" title="发表于 2024-02-21 20:31:53">2024-02-21</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/1539568593.html" title="最近公共祖先(LCA)"><img src="https://yongruizhang-image.oss-cn-chengdu.aliyuncs.com/img/Downloads/%E6%88%AA%E5%B1%8F2024-02-20%2011.07.05.png" onerror="this.onerror=null;this.src='https://yongruizhang-image.oss-cn-chengdu.aliyuncs.com/img/Downloads/404.jpg'" alt="最近公共祖先(LCA)"/></a><div class="content"><a class="title" href="/posts/1539568593.html" title="最近公共祖先(LCA)">最近公共祖先(LCA)</a><time datetime="2024-02-21T02:51:09.000Z" title="发表于 2024-02-21 10:51:09">2024-02-21</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/3523095624.html" title="数论基础"><img src="https://zyr-blog-image.oss-cn-beijing.aliyuncs.com/img102.jpg" onerror="this.onerror=null;this.src='https://yongruizhang-image.oss-cn-chengdu.aliyuncs.com/img/Downloads/404.jpg'" alt="数论基础"/></a><div class="content"><a class="title" href="/posts/3523095624.html" title="数论基础">数论基础</a><time datetime="2024-02-18T05:25:58.000Z" title="发表于 2024-02-18 13:25:58">2024-02-18</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2023 - 2024 By 秋白</div><div class="footer_custom_text"><a target="_blank" rel="noopener external nofollow noreferrer" href="https://beian.miit.gov.cn/">蜀ICP备2023012316号-1</a><br/>埋头学习 抬头恋爱<br/>本博客为个人博客，内容仅供学习参考<br/>如果文章帮到您了，或者您觉得我比较有趣请给我评论或打赏～</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="chat_btn" type="button" title="聊天"><i class="fas fa-sms"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>(()=>{
  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: 'http://101.43.224.206:8099',
      region: 'ap-beijing',
      onCommentLoaded: function () {
        btf.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.tk-owo-emotion)'))
      }
    }, null))
  }

  const getCount = () => {
    const countELement = document.getElementById('twikoo-count')
    if(!countELement) return
    twikoo.getCommentsCount({
      envId: 'http://101.43.224.206:8099',
      region: 'ap-beijing',
      urls: [window.location.pathname],
      includeReply: false
    }).then(function (res) {
      countELement.innerText = res[0].count
    }).catch(function (err) {
      console.error(err);
    });
  }

  const runFn = () => {
    init()
    GLOBAL_CONFIG_SITE.isPost && getCount()
  }

  const loadTwikoo = () => {
    if (typeof twikoo === 'object') {
      setTimeout(runFn,0)
      return
    } 
    getScript('https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js').then(runFn)
  }

  if ('Twikoo' === 'Twikoo' || !false) {
    if (false) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo()
  } else {
    window.loadOtherComment = () => {
      loadTwikoo()
    }
  }
})()</script></div><script charset="UTF-8" id="LA_COLLECT" src="//sdk.51.la/js-sdk-pro.min.js"></script><script>LA.init({id:"3HZNrBGiHwNPYZ7J",ck:"3HZNrBGiHwNPYZ7J"})</script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = false;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script>window.$crisp = [];
window.CRISP_WEBSITE_ID = "52b81d8c-40b2-40bc-bd82-3bceb709cf4b";
(function () {
  d = document;
  s = d.createElement("script");
  s.src = "https://client.crisp.chat/l.js";
  s.async = 1;
  d.getElementsByTagName("head")[0].appendChild(s);
})();
$crisp.push(["safe", true])

if (true) {
  $crisp.push(["do", "chat:hide"])
  $crisp.push(["on", "chat:closed", function() {
    $crisp.push(["do", "chat:hide"])
  }])
  var chatBtnFn = () => {
    var chatBtn = document.getElementById("chat_btn")
    chatBtn.addEventListener("click", function(){
      $crisp.push(["do", "chat:show"])
      $crisp.push(["do", "chat:open"])

    });
  }
  chatBtnFn()
} else {
  if (true) {
    function chatBtnHide () {
      $crisp.push(["do", "chat:hide"])
    }
    function chatBtnShow () {
      $crisp.push(["do", "chat:show"])
    }
  }
}</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script async>window.onload=function(){var a=document.createElement('script'),b=document.getElementsByTagName('script')[0];a.type='text/javascript',a.async=!0,a.src='/sw-register.js?v='+Date.now(),b.parentNode.insertBefore(a,b)};</script></body></html>